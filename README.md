I write programs that are maintainable, readable, and adaptable by following industry standards as well as thoroughly documenting my work and its functionality through my comments. I tend to describe what a function does and what a decision means as I go along in my programming. I also like making my code modular, with clear function purposes and the ability to re-use or re-purpose code or general code concepts as I go. In the CRUD python module, I produced a class which could take a username and password contructor parameter while having hard-coded environment variables that were separated and easy to find and define determining all the background information I wouldn't expect to change throughout the course of the module's normal operation. This was a huge advantage because it allowed easy, clean plugging into my later work. All I had to do is create my CRUDfunctionality(username, password) object, so it became easy to implement elsewhere, and to create new instances. In the future I could use the module to do projects related to database maintenance and navigation, I've considered writing my own software for two of the jobs I've had so far in order to make inventory management easier. 

As a computer scientist, I approach general problems by breaking them down into easier to navigate operations. I approach computer, logical, and mathematical problems similarly, and usually solving either problem group results in me creating some sort of list to organize my thoughts and form a gameplan, as well as make sure I don't forget or neglect any component of the problem. My approach to the Grazioso Salvare project with the dashboard interface was a little unique in that I haven't worked with HTML before this, especially not in the form of a Python Dash interface, so I had to learn the modular components around it as well as how to handle call-backs. The major difference about this approach was I felt much less control over sequences of code. I intended to connect my log-in screen with the rest of the interface by hiding the other elements or generating them after the user logs in, but this led to many errors due to call-backs relying on everything they use existing all the time. The only solution I had found was to introduce another library that allows an HTML paging system, but that seemed gratuitous and I didn't want to force my end user (my professor) to install another requirement just for my project, so I stuck with just presenting the whole dashboard with all its functionality. In the future, I'll likely create tables and then CRUD interfaces to navigate them. Having a dedicated CRUD module makes it easy! I actually applied what I learned from this course to my project in CS-360 Mobile Application Development and used the CRUD stuff to create very solid tables with inventory and user management functionality for a warehouse app, but I could see myself using Mongo for a centralized web app, like I might design one day for a large corporate intranet. 

Computer scientists solve logical and technical problems. They do this generally by developing software solutions that resolve the problems programmatically, allowing end users to solve it too and much more easily. I suppose we delegate the task of thinking to a computer at the cost of alot of thinking ourselves. It matters alot because we are tool-nakers, and very often having the right tools makes jobs easier, faster, and generally more efficient. If we make our tools well, it can reduce error and risk in any number of industries. My work on a database UI project could one day allow far easier custom unit modification and ordering for companies who rely on largely customizable projects (I used to work at Lutron Electronics, and now I work at Nord Gear Corporation, both of whom have such a model), or could help with store layout planning, modular scheduling, or other retail inventory floor management (I also used to work at Wal-Mart, for a time).  
